const express = require('express');
const vulnerabilityRouter = express.Router();
const vulnerability = require('../schema/vulnerabilityschema');
const projectDetails = require('../schema/projectschema');
const nodemailer = require('nodemailer');
const User = require('../schema/userschema');
const vulnerabilitySuggestion = require("../schema/vulnerabilitysuggestionschema")
const { authenticate, authorize, clientAuthorize } = require("../middleware/authenticate");

const transporter = nodemailer.createTransport({
    service: 'gmail',
    port: 465,
    secure: true,
    auth: {
        user: "bbnjg24@gmail.com",
        pass: "vxflraellqmguemv"
    }
});

const hasSpecialChars = (str) => /[^a-zA-Z0-9 ]/.test(str);

vulnerabilityRouter.get('/fetchvulnerability', authenticate, authorize, async (req, res) => {
    const { projectId } = req.query;
    if (!projectId) {
        return res.status(400).json({ message: 'Bad Request' });
    }
    try {
        const vulnerabilityDetails = await vulnerability.find({ projectId });
        if (vulnerabilityDetails.length === 0) {
            return res.status(404).json({ message: 'Project not found' });
        }
        res.status(200).json(vulnerabilityDetails);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal Server Error' });
    }
});


vulnerabilityRouter.put('/updatereteststatus', authenticate, authorize, async (req, res) => {
    const { vulnerabilityId, selectedOption } = req.body;
    if (hasSpecialChars(selectedOption)) {
        return res.status(400).json({ message: 'Retest status should not contain special characters' });
    }
    if(selectedOption === ''){
        return res.status(400).json({message: 'You have not selected any option'})
    }
    const io = req.app.get('io');
    try {
        const vulnerabilityDetails = await vulnerability.findOne({ _id: vulnerabilityId })
        if (!vulnerabilityDetails) {
            return res.status(404).json({ message: 'Vulnerability not found' });
        }
        vulnerabilityDetails.retestStatus = selectedOption;
        await vulnerabilityDetails.save();

        const projectId = vulnerabilityDetails.projectId
        const documentId = vulnerabilityId
        const project = await projectDetails.findById(projectId)
        const projectName = project.projectName

        io.emit('newVulnerability', { projectName });
        io.emit('viewRetestStatus', { documentId });

        return res.status(200).json({ message: 'Retest status updated successfully', vulnerability: vulnerabilityDetails });
    } catch (error) {
        console.log(error)
        res.status(500).json({ message: 'Internal Server Error' });
    }
})

vulnerabilityRouter.get('/fetchstoredvulnerabilitysuggestion',authenticate, authorize, async (req, res) => {
    try {
        const suggestions = await vulnerabilitySuggestion.find()
        // console.log(suggestions)
        res.status(200).json(suggestions)
    } catch (error) {
        console.log(error)
        res.status(500).json({ message: 'Internal Server Error' });
    }
})

// client side

vulnerabilityRouter.get('/fetchclientvulnerability', authenticate, clientAuthorize, async (req, res) => {
    const { projectName } = req.query;
    try {
        const proDetails = await projectDetails.findOne({ projectName });
        if (!proDetails) {
            return res.status(404).json({ message: 'Project not found' });
        }
        if (proDetails.email !== req.user.email) {
            return res.status(401).json({ message: 'Unauthorized' });
        }
        const projectId = proDetails._id;
        const vulnerabilityDetails = await vulnerability.find({ projectId });
        if (vulnerabilityDetails.length === 0) {
            return res.status(404).json({ message: 'Vulnerability details not found' });
        }
        res.status(200).json(vulnerabilityDetails);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal Server Error' });
    }
});

vulnerabilityRouter.post('/applyretest', authenticate, clientAuthorize, async (req, res) => {
    const { projectName } = req.body;
    try {
        const userEmail = await User.findOne({ email: req.user.email, _id: req.user.user._id });
        if (!userEmail) {
            return res.status(401).json({ message: 'Unauthorized' });
        }
        const project = await projectDetails.findOne({ email: userEmail.email, projectName });
        if (!project) {
            return res.status(401).json({ message: 'Unauthorized' });
        }
        if(project.retestApplied === true){
            return res.status(406).json({ message: "Try after 30 minutes " });
        }
        project.retestApplied = true
        project.retestAppliedExpires = new Date(Date.now() + 30 * 60 * 1000);
        await project.save();

        const mailOptions = {
            from: 'BugTrack bbnjg24@gmail.com',
            replyTo: userEmail.email,
            to: "bbnjg24@gmail.com",
            subject: `Retest Message from ${userEmail.email}`,
            html: `<h1>Hello ISECURION</h1>
                   <p>Retest message from ${userEmail.name}, ${userEmail.email}</p>
                   <p>We are happy to inform that all the vulnerabilities found in phase 1 of <b>${projectName}</b> have been fixed and it is ready for the retest.</p>
                   <br>
                   <p ><b>Best regards,</b></p>
                   <p >${userEmail.name} team</p>
                   <p >${userEmail.email}</p>`
        };
        await transporter.sendMail(mailOptions);
        res.status(200).json({ message: 'Retest request sent' });
        setTimeout(async () => {
            try {
                project.retestApplied = false
                project.retestAppliedExpires = null;
                await project.save();
            } catch (err) {
                console.error('Failed to apply retest, try after 30 minutes:', err);
            }
        }, 30 * 60 * 1000);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal Server Error' });
    }
});


vulnerabilityRouter.put('/updateclientcomment', authenticate, clientAuthorize, async (req, res) => {
    const { vulnerabilityId, comment } = req.body;

    const io = req.app.get('io');
    try {
        const vulnerabilityDetails = await vulnerability.findOne({ _id: vulnerabilityId })
        if (!vulnerabilityDetails) {
            return res.status(404).json({ message: 'Vulnerability not found' });
        }
        const project = await projectDetails.findOne({ _id: vulnerabilityDetails.projectId })
        if (!project) {
            return res.status(404).json({ message: "Project Not Found" })
        }
        if (project.email === req.user.email) {
            vulnerabilityDetails.comments = comment;
            await vulnerabilityDetails.save();
            const projectId = vulnerabilityDetails.projectId
            io.emit("fetchclientcommentandvulnerability", { projectId })
            return res.status(200).json({ message: 'Retest status updated successfully', vulnerability: vulnerabilityDetails });
        } else {
            return res.status(401).json({ message: "Unauthorized" })
        }
    } catch (error) {
        console.log(error)
        res.status(500).json({ message: 'Internal Server Error' });
    }
})

vulnerabilityRouter.get('/fetchsinglevulnerability', authenticate, clientAuthorize, async (req, res) => {
    const { vulnerabilityId } = req.query;
    try {
        const vulnerabilityDetails = await vulnerability.findOne({ _id: vulnerabilityId })
        if (!vulnerabilityDetails) {
            return res.status(404).json({ message: 'Vulnerability not found' });
        }
        const project = await projectDetails.findOne({ _id: vulnerabilityDetails.projectId })
        if (!project) {
            return res.status(404).json({ message: "Project Not Found" })
        }
        if (project.email === req.user.email) {
            return res.status(200).json(vulnerabilityDetails)
        } else {
            return res.status(401).json({ message: "Unauthorized" })
        }
    } catch (error) {
        console.log(error)
        res.status(500).json({ message: 'Internal Server Error' });
    }
})



module.exports = vulnerabilityRouter;
